---
layout: plain
---

<div class='row'><div class='col-xs-9'>
<h2 id='Macros'>Macros</h2>
<table class='table'>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro__GNU_SOURCE">#define _GNU_SOURCE </li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_ENABLE_ADDRESS_CACHE">#define ENABLE_ADDRESS_CACHE 1</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_ENABLE_PAGE_CACHE">#define ENABLE_PAGE_CACHE 1</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_MAX_PAGE_CACHE_SIZE">#define MAX_PAGE_CACHE_SIZE 512</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_AUTO">#define VMI_AUTO (1 << 0)</li>
                <li class="list-group-item"><p>libvmi should detect what to monitor or view</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_XEN">#define VMI_XEN (1 << 1)</li>
                <li class="list-group-item"><p>libvmi is monitoring a Xen VM</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_KVM">#define VMI_KVM (1 << 2)</li>
                <li class="list-group-item"><p>libvmi is monitoring a KVM VM</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_FILE">#define VMI_FILE (1 << 3)</li>
                <li class="list-group-item"><p>libvmi is viewing a file on disk</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_INIT_PARTIAL">#define VMI_INIT_PARTIAL (1 << 16)</li>
                <li class="list-group-item"><p>init enough to view physical addresses</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_INIT_COMPLETE">#define VMI_INIT_COMPLETE (1 << 17)</li>
                <li class="list-group-item"><p>full initialization</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_INIT_EVENTS">#define VMI_INIT_EVENTS (1 << 18)</li>
                <li class="list-group-item"><p>init support for memory events</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_INIT_SHM_SNAPSHOT">#define VMI_INIT_SHM_SNAPSHOT (1 << 19)</li>
                <li class="list-group-item"><p>setup shm-snapshot in vmi_init() if the feature is activated</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_CONFIG_NONE">#define VMI_CONFIG_NONE (1 << 24)</li>
                <li class="list-group-item"><p>no config provided</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_CONFIG_GLOBAL_FILE_ENTRY">#define VMI_CONFIG_GLOBAL_FILE_ENTRY (1 << 25)</li>
                <li class="list-group-item"><p>config in file provided</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_CONFIG_STRING">#define VMI_CONFIG_STRING (1 << 26)</li>
                <li class="list-group-item"><p>config string provided</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_CONFIG_GHASHTABLE">#define VMI_CONFIG_GHASHTABLE (1 << 27)</li>
                <li class="list-group-item"><p>config GHashTable provided</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_INVALID_DOMID">#define VMI_INVALID_DOMID ~0</li>
                <li class="list-group-item"><p>invalid domain id</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_GET_BIT">#define VMI_GET_BIT (reg, bit)</li>
                <li class="list-group-item"><p>Macro to test bitfield values (up to 64-bits)</p><p><strong>Value</strong><br /><small><pre>(!!(reg &amp; (1ULL&lt;&lt;bit)))</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_VMI_BIT_MASK">#define VMI_BIT_MASK (a, b)</li>
                <li class="list-group-item"><p>Macro to compute bitfield masks (up to 64-bits)</p><p><strong>Value</strong><br /><small><pre>(((unsigned long long) -1 &gt;&gt; (63 - (b))) &amp; ~((1ULL &lt;&lt; (a)) - 1))</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_MAX_SINGLESTEP_VCPUS">#define MAX_SINGLESTEP_VCPUS 32</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_SET_VCPU_SINGLESTEP">#define SET_VCPU_SINGLESTEP (ss_event, x)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>ss_event.vcpus |= (1 &lt;&lt; x)</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_UNSET_VCPU_SINGLESTEP">#define UNSET_VCPU_SINGLESTEP (ss_event, x)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>ss_event.vcpus &amp;= ~(1 &lt;&lt; x)</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_CHECK_VCPU_SINGLESTEP">#define CHECK_VCPU_SINGLESTEP (ss_event, x)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>(ss_event.vcpus) &amp; (1 &lt;&lt; x)</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_SETUP_SINGLESTEP_EVENT">#define SETUP_SINGLESTEP_EVENT (_event, _vcpu_mask, _callback)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>do { \<br />            (_event)->type = VMI_EVENT_SINGLESTEP; \<br />            (_event)->ss_event.vcpus = _vcpu_mask; \<br />            (_event)->callback = _callback; \<br />        } while(0)</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_SETUP_MEM_EVENT">#define SETUP_MEM_EVENT (_event, _addr, _granularity, _access, _callback)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>do { \<br />            (_event)->type = VMI_EVENT_MEMORY; \<br />            (_event)->mem_event.physical_address = _addr; \<br />            (_event)->mem_event.granularity = _granularity; \<br />            (_event)->mem_event.in_access = _access; \<br />            (_event)->mem_event.npages = 1; \<br />            (_event)->callback = _callback; \<br />        } while(0)</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_SETUP_REG_EVENT">#define SETUP_REG_EVENT (_event, _reg, _access, _equal, _callback)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>do { \<br />            (_event)->type = VMI_EVENT_REGISTER; \<br />            (_event)->reg_event.reg = _reg; \<br />            (_event)->reg_event.in_access = _access; \<br />            (_event)->reg_event.equal = _equal; \<br />            (_event)->callback = _callback; \<br />        } while(0)</pre></small></p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="macro_SETUP_INTERRUPT_EVENT">#define SETUP_INTERRUPT_EVENT (_event, _reinject, _callback)</li>
                <li class="list-group-item"><p><strong>Value</strong><br /><small><pre>do { \<br />            (_event)->type = VMI_EVENT_INTERRUPT; \<br />            (_event)->interrupt_event.reinject = _reinject; \<br />            (_event)->callback = _callback; \<br />        } while(0)</pre></small></p></li>
                </ul>
                </td></tr>
</table>
<h2 id='Typedefs'>Typedefs</h2>
<table class='table'>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_vmi_mode_t">typedef uint32_t vmi_mode_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_status_t">typedef enum status  status_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_os_t">typedef enum os  os_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_win_ver_t">typedef enum win_ver  win_ver_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_page_mode_t">typedef enum page_mode  page_mode_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_page_size_t">typedef enum page_size  page_size_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_reg_t">typedef uint64_t reg_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_registers_t">typedef enum registers  registers_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_addr_t">typedef uint64_t addr_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_vmi_pid_t">typedef int32_t vmi_pid_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_page_info_t">typedef struct page_info  page_info_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_translation_mechanism_t">typedef enum translation_mechanism  translation_mechanism_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_unicode_string_t">typedef struct _ustring  unicode_string_t</li>
                <li class="list-group-item"><p>Generic representation of Unicode string to be used within libvmi</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_vmi_config_t">typedef void* vmi_config_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_vmi_instance_t">typedef struct vmi_instance* vmi_instance_t</li>
                <li class="list-group-item"><p>This struct holds all of the relavent information for an instance of LibVMI. Each time a new domain is accessed, a new instance must be created using the vmi_init function. When you are done with an instance, its resources can be freed using the vmi_destroy function.</p></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_vmi_event_t">typedef struct vmi_event vmi_event_t</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="typedef_event_callback_t">typedef void(* event_callback_t) (vmi_instance_t vmi, vmi_event_t *event)</li>
                <li class="list-group-item"></li>
                </ul>
                </td></tr>
</table>
<h2 id='Enums'>Enums</h2>
<table class='table'>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_status">enum status</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_SUCCESS</td><td>return value indicating success</td></tr><tr><td>VMI_FAILURE</td><td>return value indicating failure</td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_os">enum os</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_OS_UNKNOWN</td><td>OS type is unknown</td></tr><tr><td>VMI_OS_LINUX</td><td>OS type is Linux</td></tr><tr><td>VMI_OS_WINDOWS</td><td>OS type is Windows</td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_win_ver">enum win_ver</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_OS_WINDOWS_NONE</td><td>Not Windows</td></tr><tr><td>VMI_OS_WINDOWS_UNKNOWN</td><td>Is Windows, not sure which</td></tr><tr><td>VMI_OS_WINDOWS_2000</td><td></td></tr><tr><td>VMI_OS_WINDOWS_XP</td><td></td></tr><tr><td>VMI_OS_WINDOWS_2003</td><td></td></tr><tr><td>VMI_OS_WINDOWS_VISTA</td><td></td></tr><tr><td>VMI_OS_WINDOWS_2008</td><td></td></tr><tr><td>VMI_OS_WINDOWS_7</td><td></td></tr><tr><td>VMI_OS_WINDOWS_8</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_page_mode">enum page_mode</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_PM_UNKNOWN</td><td>page mode unknown</td></tr><tr><td>VMI_PM_LEGACY</td><td>x86 32-bit paging</td></tr><tr><td>VMI_PM_PAE</td><td>x86 PAE paging</td></tr><tr><td>VMI_PM_IA32E</td><td>x86 IA-32e paging</td></tr><tr><td>VMI_PM_AARCH32</td><td>ARM 32-bit paging</td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_page_size">enum page_size</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_PS_UNKNOWN</td><td>page size unknown</td></tr><tr><td>VMI_PS_1KB</td><td>1Kb</td></tr><tr><td>VMI_PS_4KB</td><td>4Kb</td></tr><tr><td>VMI_PS_64KB</td><td>64Kb</td></tr><tr><td>VMI_PS_1MB</td><td>1Mb</td></tr><tr><td>VMI_PS_2MB</td><td>2Mb</td></tr><tr><td>VMI_PS_4MB</td><td>4Mb</td></tr><tr><td>VMI_PS_16MB</td><td>16Mb</td></tr><tr><td>VMI_PS_1GB</td><td>1GGb</td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_registers">enum registers</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>RAX</td><td></td></tr><tr><td>RBX</td><td></td></tr><tr><td>RCX</td><td></td></tr><tr><td>RDX</td><td></td></tr><tr><td>RBP</td><td></td></tr><tr><td>RSI</td><td></td></tr><tr><td>RDI</td><td></td></tr><tr><td>RSP</td><td></td></tr><tr><td>R8</td><td></td></tr><tr><td>R9</td><td></td></tr><tr><td>R10</td><td></td></tr><tr><td>R11</td><td></td></tr><tr><td>R12</td><td></td></tr><tr><td>R13</td><td></td></tr><tr><td>R14</td><td></td></tr><tr><td>R15</td><td></td></tr><tr><td>RIP</td><td></td></tr><tr><td>RFLAGS</td><td></td></tr><tr><td>CR0</td><td></td></tr><tr><td>CR2</td><td></td></tr><tr><td>CR3</td><td></td></tr><tr><td>CR4</td><td></td></tr><tr><td>DR0</td><td></td></tr><tr><td>DR1</td><td></td></tr><tr><td>DR2</td><td></td></tr><tr><td>DR3</td><td></td></tr><tr><td>DR6</td><td></td></tr><tr><td>DR7</td><td></td></tr><tr><td>CS_SEL</td><td></td></tr><tr><td>DS_SEL</td><td></td></tr><tr><td>ES_SEL</td><td></td></tr><tr><td>FS_SEL</td><td></td></tr><tr><td>GS_SEL</td><td></td></tr><tr><td>SS_SEL</td><td></td></tr><tr><td>TR_SEL</td><td></td></tr><tr><td>LDTR_SEL</td><td></td></tr><tr><td>CS_LIMIT</td><td></td></tr><tr><td>DS_LIMIT</td><td></td></tr><tr><td>ES_LIMIT</td><td></td></tr><tr><td>FS_LIMIT</td><td></td></tr><tr><td>GS_LIMIT</td><td></td></tr><tr><td>SS_LIMIT</td><td></td></tr><tr><td>TR_LIMIT</td><td></td></tr><tr><td>LDTR_LIMIT</td><td></td></tr><tr><td>IDTR_LIMIT</td><td></td></tr><tr><td>GDTR_LIMIT</td><td></td></tr><tr><td>CS_BASE</td><td></td></tr><tr><td>DS_BASE</td><td></td></tr><tr><td>ES_BASE</td><td></td></tr><tr><td>FS_BASE</td><td></td></tr><tr><td>GS_BASE</td><td></td></tr><tr><td>SS_BASE</td><td></td></tr><tr><td>TR_BASE</td><td></td></tr><tr><td>LDTR_BASE</td><td></td></tr><tr><td>IDTR_BASE</td><td></td></tr><tr><td>GDTR_BASE</td><td></td></tr><tr><td>CS_ARBYTES</td><td></td></tr><tr><td>DS_ARBYTES</td><td></td></tr><tr><td>ES_ARBYTES</td><td></td></tr><tr><td>FS_ARBYTES</td><td></td></tr><tr><td>GS_ARBYTES</td><td></td></tr><tr><td>SS_ARBYTES</td><td></td></tr><tr><td>TR_ARBYTES</td><td></td></tr><tr><td>LDTR_ARBYTES</td><td></td></tr><tr><td>SYSENTER_CS</td><td></td></tr><tr><td>SYSENTER_ESP</td><td></td></tr><tr><td>SYSENTER_EIP</td><td></td></tr><tr><td>SHADOW_GS</td><td></td></tr><tr><td>MSR_FLAGS</td><td></td></tr><tr><td>MSR_LSTAR</td><td></td></tr><tr><td>MSR_CSTAR</td><td></td></tr><tr><td>MSR_SYSCALL_MASK</td><td></td></tr><tr><td>MSR_EFER</td><td></td></tr><tr><td>MSR_TSC_AUX</td><td></td></tr><tr><td>MSR_ALL</td><td></td></tr><tr><td>TSC</td><td></td></tr><tr><td>SCTLR</td><td></td></tr><tr><td>TTBCR</td><td></td></tr><tr><td>TTBR0</td><td></td></tr><tr><td>TTBR1</td><td></td></tr><tr><td>R0_USR</td><td></td></tr><tr><td>R1_USR</td><td></td></tr><tr><td>R2_USR</td><td></td></tr><tr><td>R3_USR</td><td></td></tr><tr><td>R4_USR</td><td></td></tr><tr><td>R5_USR</td><td></td></tr><tr><td>R6_USR</td><td></td></tr><tr><td>R7_USR</td><td></td></tr><tr><td>R8_USR</td><td></td></tr><tr><td>R9_USR</td><td></td></tr><tr><td>R10_USR</td><td></td></tr><tr><td>R11_USR</td><td></td></tr><tr><td>R12_USR</td><td></td></tr><tr><td>SP_USR</td><td></td></tr><tr><td>LR_USR</td><td></td></tr><tr><td>LR_IRQ</td><td></td></tr><tr><td>SP_IRQ</td><td></td></tr><tr><td>LR_SVC</td><td></td></tr><tr><td>SP_SVC</td><td></td></tr><tr><td>LR_ABT</td><td></td></tr><tr><td>SP_ABT</td><td></td></tr><tr><td>LR_UND</td><td></td></tr><tr><td>SP_UND</td><td></td></tr><tr><td>R8_FIQ</td><td></td></tr><tr><td>R9_FIQ</td><td></td></tr><tr><td>R10_FIQ</td><td></td></tr><tr><td>R11_FIQ</td><td></td></tr><tr><td>R12_FIQ</td><td></td></tr><tr><td>SP_FIQ</td><td></td></tr><tr><td>LR_FIQ</td><td></td></tr><tr><td>PC32</td><td></td></tr><tr><td>SPSR_SVC</td><td></td></tr><tr><td>SPSR_FIQ</td><td></td></tr><tr><td>SPSR_IRQ</td><td></td></tr><tr><td>SPSR_UND</td><td></td></tr><tr><td>SPSR_ABT</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_translation_mechanism">enum translation_mechanism</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_TM_INVALID</td><td></td></tr><tr><td>VMI_TM_NONE</td><td></td></tr><tr><td>VMI_TM_PROCESS_DTB</td><td></td></tr><tr><td>VMI_TM_PROCESS_PID</td><td></td></tr><tr><td>VMI_TM_KERNEL_SYMBOL</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_vmi_event_type_t">enum vmi_event_type_t</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_EVENT_INVALID</td><td></td></tr><tr><td>VMI_EVENT_MEMORY</td><td></td></tr><tr><td>VMI_EVENT_REGISTER</td><td></td></tr><tr><td>VMI_EVENT_SINGLESTEP</td><td></td></tr><tr><td>VMI_EVENT_INTERRUPT</td><td></td></tr><tr><td>__VMI_EVENT_MAX</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_vmi_reg_access_t">enum vmi_reg_access_t</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_REGACCESS_INVALID</td><td></td></tr><tr><td>VMI_REGACCESS_N</td><td></td></tr><tr><td>VMI_REGACCESS_R</td><td></td></tr><tr><td>VMI_REGACCESS_W</td><td></td></tr><tr><td>VMI_REGACCESS_RW</td><td></td></tr><tr><td>__VMI_REGACCESS_MAX</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_vmi_mem_access_t">enum vmi_mem_access_t</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_MEMACCESS_INVALID</td><td></td></tr><tr><td>VMI_MEMACCESS_N</td><td></td></tr><tr><td>VMI_MEMACCESS_R</td><td></td></tr><tr><td>VMI_MEMACCESS_W</td><td></td></tr><tr><td>VMI_MEMACCESS_X</td><td></td></tr><tr><td>VMI_MEMACCESS_RW</td><td></td></tr><tr><td>VMI_MEMACCESS_RX</td><td></td></tr><tr><td>VMI_MEMACCESS_WX</td><td></td></tr><tr><td>VMI_MEMACCESS_RWX</td><td></td></tr><tr><td>VMI_MEMACCESS_W2X</td><td></td></tr><tr><td>VMI_MEMACCESS_RWX2N</td><td></td></tr><tr><td>__VMI_MEMACCESS_MAX</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_vmi_memevent_granularity_t">enum vmi_memevent_granularity_t</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>VMI_MEMEVENT_INVALID</td><td></td></tr><tr><td>VMI_MEMEVENT_BYTE</td><td></td></tr><tr><td>VMI_MEMEVENT_PAGE</td><td></td></tr><tr><td>__VMI_MEMEVENT_MAX</td><td></td></tr></table></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="enum_interrupts_t">enum interrupts_t</li>
                <li class="list-group-item"><table class='table table-condensed table-striped'><tr><td>INT_INVALID</td><td></td></tr><tr><td>INT3</td><td></td></tr></table></li>
                </ul>
                </td></tr>
</table>
<h2 id='Functions'>Functions</h2>
<table class='table'>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_init">status_t vmi_init (vmi_instance_t *vmi, uint32_t flags, const char *name)</li>
                <li class="list-group-item"><p>Initializes access to a specific VM or file given a name. All calls to vmi_init must eventually call vmi_destroy.</p><p>This is a costly funtion in terms of the time needed to execute. You should call this function only once per VM or file, and then use the resulting instance when calling any of the other library functions.</p><h5>Parameters</h5><ul><li>[out] <em>vmi</em> Struct that holds instance information</li><li>[in] <em>flags</em> VMI_AUTO, VMI_XEN, VMI_KVM, or VMI_FILE plus VMI_INIT_PARTIAL or VMI_INIT_COMPLETE</li><li>[in] <em>name</em> Unique name specifying the VM or file to view</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_init_custom">status_t vmi_init_custom (vmi_instance_t *vmi, uint32_t flags, vmi_config_t config)</li>
                <li class="list-group-item"><p>Initializes access to a specific VM with a custom configuration source. All calls to vmi_init_custom must eventually call vmi_destroy.</p><p>This is a costly funtion in terms of the time needed to execute. You should call this function only once per VM or file, and then use the resulting instance when calling any of the other library functions.</p><h5>Parameters</h5><ul><li>[out] <em>vmi</em> Struct that holds instance information</li><li>[in] <em>flags</em> VMI_AUTO, VMI_XEN, VMI_KVM, or VMI_FILE plus VMI_INIT_PARTIAL or VMI_INIT_COMPLETE plus VMI_CONFIG_FILE/STRING/GHASHTABLE</li><li>[in] <em>config</em> Pointer to the specified configuration structure</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_init_complete">status_t vmi_init_complete (vmi_instance_t *vmi, const char *config)</li>
                <li class="list-group-item"><p>Completes initialization. Call this after calling vmi_init with VMI_INIT_PARTIAL. Calling this at any other time results in undefined behavior. The partial init provides physical memory access only. So the purpose of this function is to allow for a staged init of LibVMI. You can gain physical memory access, run some heuristics to obtain the necessary offsets, and then complete the init.</p><h5>Parameters</h5><ul><li>[inout] <em>vmi</em> Struct that holds the instance information and was passed to vmi_init with a VMI_INIT_PARTIAL flag</li><li>[in] <em>config</em> Pointer to a string containing the config entries for this domain. Entries should be specified as in the config file (e.g., '{ostype = "Windows"; win_tasks = 0x88; win_pdbase = 0x18; ...}'). If this is NULL, then the config is pulled from /etc/libvmi.conf.</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_init_complete_custom">status_t vmi_init_complete_custom (vmi_instance_t *vmi, uint32_t flags, vmi_config_t config)</li>
                <li class="list-group-item"><p>Completes initialization. Call this after calling vmi_init or vmi_init_custom with VMI_INIT_PARTIAL. Calling this at any other time results in undefined behavior. The partial init provides physical memory access only. So the purpose of this function is to allow for a staged init of LibVMI. You can gain physical memory access, run some heuristics to obtain the necessary offsets, and then complete the init.</p><h5>Parameters</h5><ul><li>[inout] <em>vmi</em> Struct that holds the instance information and was passed to vmi_init with a VMI_INIT_PARTIAL flag</li><li>[in] <em>flags</em> VMI_CONFIG_FILE/STRING/GHASHTABLE</li><li>[in] <em>config</em> Pointer to a structure containing the config entries for this domain.</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_init_paging">page_mode_t vmi_init_paging (vmi_instance_t vmi, uint8_t force_reinit)</li>
                <li class="list-group-item"><p>Initialize or reinitialize the paging specific functionality of LibVMI. This function is most useful when dynamically monitoring the booting of an OS in VMI_INIT_PARTIAL mode.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>force_reinit</em> Force the reinitialization of the paging mode even if one was already setup previously.</li></ul><h5>Returns</h5><ul><li>The current page mode of the architecture or VMI_PM_UNKNOWN.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_destroy">status_t vmi_destroy (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Destroys an instance by freeing memory and closing any open handles.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> Instance to destroy</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_translate_kv2p">addr_t vmi_translate_kv2p (vmi_instance_t vmi, addr_t vaddr)</li>
                <li class="list-group-item"><p>Performs the translation from a kernel virtual address to a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Desired kernel virtual address to translate</li></ul><h5>Returns</h5><ul><li>Physical address, or zero on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_translate_uv2p">addr_t vmi_translate_uv2p (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid)</li>
                <li class="list-group-item"><p>Performs the translation from a user virtual address to a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Desired kernel virtual address to translate</li><li>[in] <em>pid</em> Process id for desired user address space</li></ul><h5>Returns</h5><ul><li>Physical address, or zero on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_translate_ksym2v">addr_t vmi_translate_ksym2v (vmi_instance_t vmi, const char *symbol)</li>
                <li class="list-group-item"><p>Performs the translation from a kernel symbol to a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>symbol</em> Desired kernel symbol to translate</li></ul><h5>Returns</h5><ul><li>Virtual address, or zero on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_translate_sym2v">addr_t vmi_translate_sym2v (vmi_instance_t vmi, addr_t base_vaddr, vmi_pid_t pid, char *symbol)</li>
                <li class="list-group-item"><p>Performs the translation from a symbol to a virtual address. On Windows this function walks the PE export table. Linux is unimplemented at this time.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>base_vaddr</em> Base virtual address (beginning of PE header in Windows)</li><li>[in] <em>pid</em> PID</li><li>[in] <em>symbol</em> Desired symbol to translate</li></ul><h5>Returns</h5><ul><li>Virtual address, or zero on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_translate_v2sym">const char* vmi_translate_v2sym (vmi_instance_t vmi, addr_t base_vaddr, vmi_pid_t pid, addr_t rva)</li>
                <li class="list-group-item"><p>Performs the translation from an RVA to a symbol On Windows this function walks the PE export table. Linux is unimplemented at this time.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>base_vaddr</em> Base virtual address (beginning of PE header in Windows)</li><li>[in] <em>pid</em> PID</li><li>[in] <em>rva</em> RVA to translate</li></ul><h5>Returns</h5><ul><li>Symbol, or NULL on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_pid_to_dtb">addr_t vmi_pid_to_dtb (vmi_instance_t vmi, vmi_pid_t pid)</li>
                <li class="list-group-item"><p>Given a pid, this function returns the virtual address of the directory table base for this process' address space. This value is effectively what would be in the CR3 register while this process is running.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>pid</em> Desired process id to lookup</li></ul><h5>Returns</h5><ul><li>OrderedDict([(u'emphasis', u'pid'), ('#text', u'The directory table base virtual address for')])</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_dtb_to_pid">vmi_pid_t vmi_dtb_to_pid (vmi_instance_t vmi, addr_t dtb)</li>
                <li class="list-group-item"><p>Given a dtb, this function returns the PID corresponding to the virtual address of the directory table base. This function does NOT implement caching as to avoid false mappings.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>dtb</em> Desired dtb to lookup</li></ul><h5>Returns</h5><ul><li>The PID corresponding to the dtb</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_pagetable_lookup">addr_t vmi_pagetable_lookup (vmi_instance_t vmi, addr_t dtb, addr_t vaddr)</li>
                <li class="list-group-item"><p>Translates a virtual address to a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>dtb</em> address of the relevant page directory base</li><li>[in] <em>vaddr</em> virtual address to translate via dtb</li></ul><h5>Returns</h5><ul><li>Physical address, or zero on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_pagetable_lookup_extended">status_t vmi_pagetable_lookup_extended (vmi_instance_t vmi, addr_t dtb, addr_t vaddr, page_info_t *info)</li>
                <li class="list-group-item"><p>Gets the physical address and page size of the VA as well as the addresses of other paging related structures depending on the page mode of the VM.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>dtb</em> address of the relevant page directory base</li><li>[in] <em>vaddr</em> virtual address to translate via dtb</li><li>[inout] <em>info</em> Pointer to the struct to store the lookup information in</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE of the VA is invalid</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read">size_t vmi_read (vmi_instance_t vmi, access_context_t *ctx, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Reads <em>count</em> bytes from memory and stores the output in <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[out] <em>buf</em> The data read from memory</li><li>[in] <em>count</em> The number of bytes to read</li></ul><h5>Returns</h5><ul><li>The number of bytes read.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_8">status_t vmi_read_8 (vmi_instance_t vmi, access_context_t *ctx, uint8_t *value)</li>
                <li class="list-group-item"><p>Reads 8 bits from memory.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_16">status_t vmi_read_16 (vmi_instance_t vmi, access_context_t *ctx, uint16_t *value)</li>
                <li class="list-group-item"><p>Reads 16 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_32">status_t vmi_read_32 (vmi_instance_t vmi, access_context_t *ctx, uint32_t *value)</li>
                <li class="list-group-item"><p>Reads 32 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_64">status_t vmi_read_64 (vmi_instance_t vmi, access_context_t *ctx, uint64_t *value)</li>
                <li class="list-group-item"><p>Reads 64 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_addr">status_t vmi_read_addr (vmi_instance_t vmi, access_context_t *ctx, addr_t *value)</li>
                <li class="list-group-item"><p>Reads an address from memory, given a virtual address. The number of bytes read is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_str">char* vmi_read_str (vmi_instance_t vmi, access_context_t *ctx)</li>
                <li class="list-group-item"><p>Reads a null terminated string from memory, starting at the given virtual address. The returned value must be freed by the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li></ul><h5>Returns</h5><ul><li>String read from memory or NULL on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_ksym">size_t vmi_read_ksym (vmi_instance_t vmi, char *sym, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Reads <em>count</em> bytes from memory located at the kernel symbol <em>sym</em> and stores the output in <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to read from</li><li>[out] <em>buf</em> The data read from memory</li><li>[in] <em>count</em> The number of bytes to read</li></ul><h5>Returns</h5><ul><li>The number of bytes read.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_va">size_t vmi_read_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Reads <em>count</em> bytes from memory located at the virtual address <em>vaddr</em> and stores the output in <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>buf</em> The data read from memory</li><li>[in] <em>count</em> The number of bytes to read</li></ul><h5>Returns</h5><ul><li>The number of bytes read.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_pa">size_t vmi_read_pa (vmi_instance_t vmi, addr_t paddr, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Reads <em>count</em> bytes from memory located at the physical address <em>paddr</em> and stores the output in <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to read from</li><li>[out] <em>buf</em> The data read from memory</li><li>[in] <em>count</em> The number of bytes to read</li></ul><h5>Returns</h5><ul><li>The number of bytes read.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_8_ksym">status_t vmi_read_8_ksym (vmi_instance_t vmi, char *sym, uint8_t *value)</li>
                <li class="list-group-item"><p>Reads 8 bits from memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_16_ksym">status_t vmi_read_16_ksym (vmi_instance_t vmi, char *sym, uint16_t *value)</li>
                <li class="list-group-item"><p>Reads 16 bits from memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_32_ksym">status_t vmi_read_32_ksym (vmi_instance_t vmi, char *sym, uint32_t *value)</li>
                <li class="list-group-item"><p>Reads 32 bits from memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_64_ksym">status_t vmi_read_64_ksym (vmi_instance_t vmi, char *sym, uint64_t *value)</li>
                <li class="list-group-item"><p>Reads 64 bits from memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_addr_ksym">status_t vmi_read_addr_ksym (vmi_instance_t vmi, char *sym, addr_t *value)</li>
                <li class="list-group-item"><p>Reads an address from memory, given a kernel symbol. The number of bytes read is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_str_ksym">char* vmi_read_str_ksym (vmi_instance_t vmi, char *sym)</li>
                <li class="list-group-item"><p>Reads a null-terminated string from memory, starting at the given kernel symbol. The returned value must be freed by the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol for memory location where string starts</li></ul><h5>Returns</h5><ul><li>String read from memory or NULL on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_8_va">status_t vmi_read_8_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint8_t *value)</li>
                <li class="list-group-item"><p>Reads 8 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_16_va">status_t vmi_read_16_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint16_t *value)</li>
                <li class="list-group-item"><p>Reads 16 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_32_va">status_t vmi_read_32_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint32_t *value)</li>
                <li class="list-group-item"><p>Reads 32 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_64_va">status_t vmi_read_64_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint64_t *value)</li>
                <li class="list-group-item"><p>Reads 64 bits from memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_addr_va">status_t vmi_read_addr_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, addr_t *value)</li>
                <li class="list-group-item"><p>Reads an address from memory, given a virtual address. The number of bytes read is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to read from</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_str_va">char* vmi_read_str_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid)</li>
                <li class="list-group-item"><p>Reads a null terminated string from memory, starting at the given virtual address. The returned value must be freed by the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address for start of string</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li></ul><h5>Returns</h5><ul><li>String read from memory or NULL on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_unicode_str_va">unicode_string_t* vmi_read_unicode_str_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid)</li>
                <li class="list-group-item"><p>Reads a Unicode string from the given address. If the guest is running Windows, a UNICODE_STRING struct is read. Linux is not yet supported. The returned value must be freed by the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address of the UNICODE_STRING structure</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li></ul><h5>Returns</h5><ul><li>String read from memory or NULL on error; this function will set the encoding field.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_convert_str_encoding">status_t vmi_convert_str_encoding (const unicode_string_t *in, unicode_string_t *out, const char *outencoding)</li>
                <li class="list-group-item"><p>Converts character encoding from that in the input string to another specified encoding. Two common ways to use this function are: (1) convert a string to the "UTF-8" encoding and output with printf("%s"); (2) convert a string to the "WCHAR_T" encoding and output with printf("%ls").</p><h5>Parameters</h5><ul><li>[in] <em>in</em> unicode_string_t to be converted; encoding field must be set</li><li>[in] <em>out</em> output unicode_string_t, allocated by caller (this function allocates the contents field)</li><li>[in] <em>outencoding</em> output encoding, must be compatible with the iconv function</li></ul><h5>Returns</h5><ul><li>status code</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_free_unicode_str">void vmi_free_unicode_str (unicode_string_t *p_us)</li>
                <li class="list-group-item"><p>Convenience function to free a unicode_string_t struct.</p><h5>Parameters</h5><ul><li>[in] <em>p_us</em> Pointer to a unicode_string_t struct</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_8_pa">status_t vmi_read_8_pa (vmi_instance_t vmi, addr_t paddr, uint8_t *value)</li>
                <li class="list-group-item"><p>Reads 8 bits from memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_16_pa">status_t vmi_read_16_pa (vmi_instance_t vmi, addr_t paddr, uint16_t *value)</li>
                <li class="list-group-item"><p>Reads 16 bits from memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_32_pa">status_t vmi_read_32_pa (vmi_instance_t vmi, addr_t paddr, uint32_t *value)</li>
                <li class="list-group-item"><p>Reads 32 bits from memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_64_pa">status_t vmi_read_64_pa (vmi_instance_t vmi, addr_t paddr, uint64_t *value)</li>
                <li class="list-group-item"><p>Reads 64 bits from memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_addr_pa">status_t vmi_read_addr_pa (vmi_instance_t vmi, addr_t paddr, addr_t *value)</li>
                <li class="list-group-item"><p>Reads an address from memory, given a physical address. The number of bytes read is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to read from</li><li>[out] <em>value</em> The value read from memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_read_str_pa">char* vmi_read_str_pa (vmi_instance_t vmi, addr_t paddr)</li>
                <li class="list-group-item"><p>Reads a nul terminated string from memory, starting at the given physical address. The returned value must be freed by the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address for start of string</li></ul><h5>Returns</h5><ul><li>String read from memory or NULL on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write">size_t vmi_write (vmi_instance_t vmi, access_context_t *ctx, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Writes <em>count</em> bytes to memory</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[in] <em>buf</em> The data written to memory</li><li>[in] <em>count</em> The number of bytes to write</li></ul><h5>Returns</h5><ul><li>The number of bytes written.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_ksym">size_t vmi_write_ksym (vmi_instance_t vmi, char *sym, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Writes <em>count</em> bytes to memory located at the kernel symbol <em>sym</em> from <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to write to</li><li>[in] <em>buf</em> The data written to memory</li><li>[in] <em>count</em> The number of bytes to write</li></ul><h5>Returns</h5><ul><li>The number of bytes written.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_va">size_t vmi_write_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Writes <em>count</em> bytes to memory located at the virtual address <em>vaddr</em> from <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to write to</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>buf</em> The data written to memory</li><li>[in] <em>count</em> The number of bytes to write</li></ul><h5>Returns</h5><ul><li>The number of bytes written.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_pa">size_t vmi_write_pa (vmi_instance_t vmi, addr_t paddr, void *buf, size_t count)</li>
                <li class="list-group-item"><p>Writes <em>count</em> bytes to memory located at the physical address <em>paddr</em> from <em>buf</em>.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to write to</li><li>[in] <em>buf</em> The data written to memory</li><li>[in] <em>count</em> The number of bytes to write</li></ul><h5>Returns</h5><ul><li>The number of bytes written.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_8">status_t vmi_write_8 (vmi_instance_t vmi, access_context_t *ctx, uint8_t *value)</li>
                <li class="list-group-item"><p>Writes 8 bits to memory</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_16">status_t vmi_write_16 (vmi_instance_t vmi, access_context_t *ctx, uint16_t *value)</li>
                <li class="list-group-item"><p>Writes 16 bits to memory</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_32">status_t vmi_write_32 (vmi_instance_t vmi, access_context_t *ctx, uint32_t *value)</li>
                <li class="list-group-item"><p>Writes 32 bits to memory</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_64">status_t vmi_write_64 (vmi_instance_t vmi, access_context_t *ctx, uint64_t *value)</li>
                <li class="list-group-item"><p>Writes 64 bits to memory</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_addr">status_t vmi_write_addr (vmi_instance_t vmi, access_context_t *ctx, addr_t *value)</li>
                <li class="list-group-item"><p>Writes the address to memory. The number of bytes written is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>ctx</em> Access context</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_8_ksym">status_t vmi_write_8_ksym (vmi_instance_t vmi, char *sym, uint8_t *value)</li>
                <li class="list-group-item"><p>Writes 8 bits to memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_16_ksym">status_t vmi_write_16_ksym (vmi_instance_t vmi, char *sym, uint16_t *value)</li>
                <li class="list-group-item"><p>Writes 16 bits to memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_32_ksym">status_t vmi_write_32_ksym (vmi_instance_t vmi, char *sym, uint32_t *value)</li>
                <li class="list-group-item"><p>Writes 32 bits to memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_64_ksym">status_t vmi_write_64_ksym (vmi_instance_t vmi, char *sym, uint64_t *value)</li>
                <li class="list-group-item"><p>Writes 64 bits to memory, given a kernel symbol.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_addr_ksym">status_t vmi_write_addr_ksym (vmi_instance_t vmi, char *sym, addr_t *value)</li>
                <li class="list-group-item"><p>Writes the address to memory. The number of bytes written is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_8_va">status_t vmi_write_8_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint8_t *value)</li>
                <li class="list-group-item"><p>Writes 8 bits to memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to write to</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_16_va">status_t vmi_write_16_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint16_t *value)</li>
                <li class="list-group-item"><p>Writes 16 bits to memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to write to</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_32_va">status_t vmi_write_32_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint32_t *value)</li>
                <li class="list-group-item"><p>Writes 32 bits to memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to write to</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_64_va">status_t vmi_write_64_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, uint64_t *value)</li>
                <li class="list-group-item"><p>Writes 64 bits to memory, given a virtual address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to write to</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_addr_va">status_t vmi_write_addr_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, addr_t *value)</li>
                <li class="list-group-item"><p>Writes the address to memory. The number of bytes written is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to write to</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_8_pa">status_t vmi_write_8_pa (vmi_instance_t vmi, addr_t paddr, uint8_t *value)</li>
                <li class="list-group-item"><p>Writes 8 bits to memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_16_pa">status_t vmi_write_16_pa (vmi_instance_t vmi, addr_t paddr, uint16_t *value)</li>
                <li class="list-group-item"><p>Writes 16 bits to memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_32_pa">status_t vmi_write_32_pa (vmi_instance_t vmi, addr_t paddr, uint32_t *value)</li>
                <li class="list-group-item"><p>Writes 32 bits to memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_64_pa">status_t vmi_write_64_pa (vmi_instance_t vmi, addr_t paddr, uint64_t *value)</li>
                <li class="list-group-item"><p>Writes 64 bits from memory, given a physical address.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_write_addr_pa">status_t vmi_write_addr_pa (vmi_instance_t vmi, addr_t paddr, addr_t *value)</li>
                <li class="list-group-item"><p>Writes the address to memory. The number of bytes written is 8 for 64-bit systems and 4 for 32-bit systems.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to write to</li><li>[in] <em>value</em> The value written to memory</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_print_hex">void vmi_print_hex (unsigned char *data, unsigned long length)</li>
                <li class="list-group-item"><p>Prints out the hex and ascii version of a chunk of bytes. The output is similar to what you would get with 'od -h' with the additional ascii information on the right side of the display.</p><h5>Parameters</h5><ul><li>[in] <em>data</em> The bytes that will be printed to stdout</li><li>[in] <em>length</em> The length (in bytes) of data</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_print_hex_ksym">void vmi_print_hex_ksym (vmi_instance_t vmi, char *sym, size_t length)</li>
                <li class="list-group-item"><p>Prints out the hex and ascii version of a chunk of bytes. The output is similar to what you would get with 'od -h' with the additional ascii information on the right side of the display.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>sym</em> Kernel symbol to use as starting address</li><li>[in] <em>length</em> The length (in bytes) of data to print</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_print_hex_va">void vmi_print_hex_va (vmi_instance_t vmi, addr_t vaddr, vmi_pid_t pid, size_t length)</li>
                <li class="list-group-item"><p>Prints out the hex and ascii version of a chunk of bytes. The output is similar to what you would get with 'od -h' with the additional ascii information on the right side of the display.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vaddr</em> Virtual address to use as starting address</li><li>[in] <em>pid</em> Pid of the virtual address space (0 for kernel)</li><li>[in] <em>length</em> The length (in bytes) of data to print</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_print_hex_pa">void vmi_print_hex_pa (vmi_instance_t vmi, addr_t paddr, size_t length)</li>
                <li class="list-group-item"><p>Prints out the hex and ascii version of a chunk of bytes. The output is similar to what you would get with 'od -h' with the additional ascii information on the right side of the display.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>paddr</em> Physical address to use as starting address</li><li>[in] <em>length</em> The length (in bytes) of data to print</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_name">char* vmi_get_name (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the name of the VM (or file) that LibVMI is accessing.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>VM (or file) name, must be free'd by caller</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_vmid">unsigned long vmi_get_vmid (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the id of the VM that LibVMI is accessing.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>VM id, or zero on error</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_access_mode">uint32_t vmi_get_access_mode (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the current access mode for LibVMI, which tells what resource is being using to access the memory (e.g., VMI_XEN, VMI_KVM, or VMI_FILE).</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>Access mode</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_page_mode">page_mode_t vmi_get_page_mode (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the current page mode for LibVMI, which tells what type of address translation is in use (e.g., VMI_PM_LEGACY, VMI_PM_PAE, or VMI_PM_IA32E).</p><p>If paging mode is altered after vmi_init, the information preserved in vmi_instance_t will have become stale and require re-initialization.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>Page mode</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_address_width">uint8_t vmi_get_address_width (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the current address width for the given vmi_instance_t</p><p>Note: relative to the OS mode, not that of a process. Also, if paging mode is altered after vmi_init, the information as recorded in vmi_instance_t will be stale and require re-initialization.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>address size in bytes</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_ostype">os_t vmi_get_ostype (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Get the OS type that LibVMI is currently accessing. This is simple windows or linux (no version information).</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>OS type</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_winver">win_ver_t vmi_get_winver (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Get the version of Windows that LibVMI is currently accessing. This is the simple Windows version - no service pack or patch level is provided.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>Windows version</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_winver_str">const char* vmi_get_winver_str (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Get string represenatation of the version of Windows that LibVMI is currently accessing.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>string description of Windows version (do not free)</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_winver_manual">win_ver_t vmi_get_winver_manual (vmi_instance_t vmi, addr_t kdvb_pa)</li>
                <li class="list-group-item"><p>Get the version of Windows based on the provided KDVB address. This is the simple Windows version - no service pack or patch level is provided.</p><p>This function is intended to be used during partial init as an aid to elevate to full init.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>kdvb_pa</em> The physical address of the KDVB</li></ul><h5>Returns</h5><ul><li>Windows version</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_offset">uint64_t vmi_get_offset (vmi_instance_t vmi, char *offset_name)</li>
                <li class="list-group-item"><p>Get the memory offset associated with the given offset_name. Valid names include everything in the /etc/libvmi.conf file.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>offset_name</em> String name for desired offset</li></ul><h5>Returns</h5><ul><li>The offset value</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_memsize">uint64_t vmi_get_memsize (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the memory size of the guest or file that LibVMI is currently accessing. This is effectively the max physical address that you can access in the system.</p><p>NOTE: if memory ballooning alters the allocation of memory to a VM after vmi_init, this information will have become stale and a re-initialization will be required.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>Memory size</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_num_vcpus">unsigned int vmi_get_num_vcpus (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Gets the memory size of the guest that LibVMI is accessing. This information is required for any interaction with of VCPU registers.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>Number of VCPUs</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_vcpureg">status_t vmi_get_vcpureg (vmi_instance_t vmi, reg_t *value, registers_t reg, unsigned long vcpu)</li>
                <li class="list-group-item"><p>Gets the current value of a VCPU register. This currently only supports control registers. When LibVMI is accessing a raw memory file, this function will fail.</p><p>NOTE: for some hypervisor drivers, it is important to understand the validity of the values that registers hold. For example, CR3 for Xen paravirtual VMs may hold a physical address higher than the maximum psuedophysical address of the given VM (this is an expected and correct idiosyncrasy of that platform). Similar scenarios exist for IDTR, etc.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[out] <em>value</em> Returned value from the register, only valid on VMI_SUCCESS</li><li>[in] <em>reg</em> The register to access</li><li>[in] <em>vcpu</em> The index of the VCPU to access, use 0 for single VCPU systems</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_set_vcpureg">status_t vmi_set_vcpureg (vmi_instance_t vmi, reg_t value, registers_t reg, unsigned long vcpu)</li>
                <li class="list-group-item"><p>Sets the current value of a VCPU register. This currently only supports control registers. When LibVMI is accessing a raw memory file, this function will fail. Operating upon an unpaused VM with this function is likely to have unexpected results.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>value</em> Value to assign to the register</li><li>[in] <em>reg</em> The register to access</li><li>[in] <em>vcpu</em> The index of the VCPU to access, use 0 for single VCPU systems</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_pause_vm">status_t vmi_pause_vm (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Pauses the VM. Use vmi_resume_vm to resume the VM after pausing it. If accessing a memory file, this has no effect.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_resume_vm">status_t vmi_resume_vm (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Resumes the VM. Use vmi_pause_vm to pause the VM before calling this function. If accessing a memory file, this has no effect.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_v2pcache_flush">void vmi_v2pcache_flush (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Removes all entries from LibVMI's internal virtual to physical address cache. This is generally only useful if you believe that an entry in the cache is incorrect, or out of date.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_v2pcache_add">void vmi_v2pcache_add (vmi_instance_t vmi, addr_t va, addr_t dtb, addr_t pa)</li>
                <li class="list-group-item"><p>Adds one entry to LibVMI's internal virtual to physical address cache.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>va</em> Virtual address</li><li>[in] <em>dtb</em> OrderedDict([(u'emphasis', u'va'), ('#text', u'Directory table base for')])</li><li>[in] <em>pa</em> Physical address</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_symcache_flush">void vmi_symcache_flush (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Removes all entries from LibVMI's internal kernel symbol to virtual address cache. This is generally only useful if you believe that an entry in the cache is incorrect, or out of date.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_symcache_add">void vmi_symcache_add (vmi_instance_t vmi, addr_t base_addr, vmi_pid_t pid, char *sym, addr_t va)</li>
                <li class="list-group-item"><p>Adds one entry to LibVMI's internal symbol to virtual address cache.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>base_addr</em> Base address</li><li>[in] <em>pid</em> PID</li><li>[in] <em>sym</em> Symbol</li><li>[in] <em>va</em> Virtual address</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_rvacache_flush">void vmi_rvacache_flush (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Removes all entries from LibVMI's internal RVA to symbol cache. This is generally only useful if you believe that an entry in the cache is incorrect, or out of date.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_rvacache_add">void vmi_rvacache_add (vmi_instance_t vmi, addr_t base_addr, vmi_pid_t pid, addr_t rva, char *sym)</li>
                <li class="list-group-item"><p>Adds one entry to LibVMI's internal RVA to symbol cache.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>base_addr</em> Base address</li><li>[in] <em>pid</em> PID</li><li>[in] <em>rva</em> Relative virtual address</li><li>[in] <em>sym</em> Symbol</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_pidcache_flush">void vmi_pidcache_flush (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Removes all entries from LibVMI's internal pid to directory table base cache. This is generally only useful if you believe that an entry in the cache is incorrect, or out of date.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_pidcache_add">void vmi_pidcache_add (vmi_instance_t vmi, vmi_pid_t pid, addr_t dtb)</li>
                <li class="list-group-item"><p>Adds one entry to LibVMI's internal pid to directory table base cache.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>pid</em> Process id</li><li>[in] <em>dtb</em> Directory table base</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_register_event">status_t vmi_register_event (vmi_instance_t vmi, vmi_event_t *event)</li>
                <li class="list-group-item"><p>Callback receives one event as input. Callback is invoked while within the event listener loop, so actions taken by the callback must take into account that other events may have been delivered and not yet processed. This is especially important when events have been configured in an asyncronous manner (i.e., events delivered are not necessarily in lockstep with the VM state).</p><p>Memory management of the vmi_event_t being registered remains the responsibility of the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>event</em> Definition of event to monitor</li><li>[in] <em>callback</em> Function to call when the event occurs</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_clear_event">status_t vmi_clear_event (vmi_instance_t vmi, vmi_event_t *event)</li>
                <li class="list-group-item"><p>Clear the event specified by the vmi_event_t object.</p><p>For memory events, this operation resets page permissions so that execution relative to related page or pages can continue without further interaction. For register and single-step events, this action disables monitoring of the given event type via the hypervisor driver. In all cases, the event is removed from hashtables internal to LibVMI, but the memory related to the vmi_event_t is not freed. Memory management remains the responsibility of the caller.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>event</em> Definition of event to clear</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_reg_event">vmi_event_t* vmi_get_reg_event (vmi_instance_t vmi, registers_t reg)</li>
                <li class="list-group-item"><p>Return the pointer to the vmi_event_t if one is set on the given register.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>reg</em> Register to check</li></ul><h5>Returns</h5><ul><li>vmi_event_t* or NULL if none found</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_mem_event">vmi_event_t* vmi_get_mem_event (vmi_instance_t vmi, addr_t physical_address, vmi_memevent_granularity_t granularity)</li>
                <li class="list-group-item"><p>Return the pointer to the vmi_event_t if one is set on the given page.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>physical_address</em> Physical address of byte/page to check</li><li>[in] <em>granularity</em> VMI_MEMEVENT_BYTE or VMI_MEMEVENT_PAGE</li></ul><h5>Returns</h5><ul><li>vmi_event_t* or NULL if none found</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_step_event">status_t vmi_step_event (vmi_instance_t vmi, vmi_event_t *event, uint32_t vcpu_id, uint64_t steps, event_callback_t cb)</li>
                <li class="list-group-item"><p>Setup single-stepping to register the given event after the specified number of steps.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>event</em> The event to register</li><li>[in] <em>vcpu_id</em> The vCPU ID to step the event on.</li><li>[in] <em>steps</em> The number of steps to take before registering the event</li><li>[in] <em>cb</em> Optional: A callback function to call after the specified number of steps. If no callback is provided, the event will be re-registered automatically. If a callback is provided, event re-registration is not automatic, but can be done in the callback.</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_events_listen">status_t vmi_events_listen (vmi_instance_t vmi, uint32_t timeout)</li>
                <li class="list-group-item"><p>Listen for events until one occurs or a timeout. If the timeout is given as 0, it will process leftover events in the ring-buffer (if there are any).</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>timeout</em> Number of ms.</li></ul><h5>Returns</h5><ul><li>VMI_FAILURE or VMI_SUCCESS (timeout w/ 0 events returns VMI_SUCCESS)</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_event_listener_required">status_t vmi_event_listener_required (vmi_instance_t vmi, int required)</li>
                <li class="list-group-item"><p>Set wether to pause the domain if the event listener is no longer present.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>required</em> Set to 0 if not required, 1 if required.</li></ul><h5>Returns</h5><ul><li>VMI_FAILURE or VMI_SUCCESS</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_are_events_pending">int vmi_are_events_pending (vmi_instance_t vmi)</li>
                <li class="list-group-item"><p>Check if there are events pending to be processed.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>The number of pending events, or 0 if there are non, -1 on error.</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_get_singlestep_event">vmi_event_t* vmi_get_singlestep_event (vmi_instance_t vmi, uint32_t vcpu)</li>
                <li class="list-group-item"><p>Return the pointer to the vmi_event_t if one is set on the given vcpu.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>vcpu</em> the vcpu to check</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_stop_single_step_vcpu">status_t vmi_stop_single_step_vcpu (vmi_instance_t vmi, vmi_event_t *event, uint32_t vcpu)</li>
                <li class="list-group-item"><p>Disables the MTF single step flag from a vcpu as well as the libvmi event object's bitfield position. This does not disable single step for the whole domain.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li><li>[in] <em>event</em> the event to disable the vcpu on</li><li>[in] <em>vcpu</em> the vcpu to stop single stepping on</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
<tr><td>
                <ul class="list-group">
                <li class="list-group-item active" id="func_vmi_shutdown_single_step">status_t vmi_shutdown_single_step (vmi_instance_t)</li>
                <li class="list-group-item"><p>Cleans up any domain wide single step settings. This should be called when the caller is completely finished with single step, as it implicitly disables single-step on all VM VCPUs.</p><h5>Parameters</h5><ul><li>[in] <em>vmi</em> LibVMI instance</li></ul><h5>Returns</h5><ul><li>VMI_SUCCESS or VMI_FAILURE</li></ul></li>
                </ul>
                </td></tr>
</table>
</div>

    <nav class="col-xs-3">
      <div class="bs-docs-sidebar">
    

    <ul class="nav nav-stacked">
    
<li>
<a href='#Macros'>Macros</a>
<ul class='nav nav-stacked'>
<li><a href='#macro__GNU_SOURCE'>_GNU_SOURCE</a></li>
<li><a href='#macro_ENABLE_ADDRESS_CACHE'>ENABLE_ADDRESS_CACHE</a></li>
<li><a href='#macro_ENABLE_PAGE_CACHE'>ENABLE_PAGE_CACHE</a></li>
<li><a href='#macro_MAX_PAGE_CACHE_SIZE'>MAX_PAGE_CACHE_SIZE</a></li>
<li><a href='#macro_VMI_AUTO'>VMI_AUTO</a></li>
<li><a href='#macro_VMI_XEN'>VMI_XEN</a></li>
<li><a href='#macro_VMI_KVM'>VMI_KVM</a></li>
<li><a href='#macro_VMI_FILE'>VMI_FILE</a></li>
<li><a href='#macro_VMI_INIT_PARTIAL'>VMI_INIT_PARTIAL</a></li>
<li><a href='#macro_VMI_INIT_COMPLETE'>VMI_INIT_COMPLETE</a></li>
<li><a href='#macro_VMI_INIT_EVENTS'>VMI_INIT_EVENTS</a></li>
<li><a href='#macro_VMI_INIT_SHM_SNAPSHOT'>VMI_INIT_SHM_SNAPSHOT</a></li>
<li><a href='#macro_VMI_CONFIG_NONE'>VMI_CONFIG_NONE</a></li>
<li><a href='#macro_VMI_CONFIG_GLOBAL_FILE_ENTRY'>VMI_CONFIG_GLOBAL_FILE_ENTRY</a></li>
<li><a href='#macro_VMI_CONFIG_STRING'>VMI_CONFIG_STRING</a></li>
<li><a href='#macro_VMI_CONFIG_GHASHTABLE'>VMI_CONFIG_GHASHTABLE</a></li>
<li><a href='#macro_VMI_INVALID_DOMID'>VMI_INVALID_DOMID</a></li>
<li><a href='#macro_VMI_GET_BIT'>VMI_GET_BIT</a></li>
<li><a href='#macro_VMI_BIT_MASK'>VMI_BIT_MASK</a></li>
<li><a href='#macro_MAX_SINGLESTEP_VCPUS'>MAX_SINGLESTEP_VCPUS</a></li>
<li><a href='#macro_SET_VCPU_SINGLESTEP'>SET_VCPU_SINGLESTEP</a></li>
<li><a href='#macro_UNSET_VCPU_SINGLESTEP'>UNSET_VCPU_SINGLESTEP</a></li>
<li><a href='#macro_CHECK_VCPU_SINGLESTEP'>CHECK_VCPU_SINGLESTEP</a></li>
<li><a href='#macro_SETUP_SINGLESTEP_EVENT'>SETUP_SINGLESTEP_EVENT</a></li>
<li><a href='#macro_SETUP_MEM_EVENT'>SETUP_MEM_EVENT</a></li>
<li><a href='#macro_SETUP_REG_EVENT'>SETUP_REG_EVENT</a></li>
<li><a href='#macro_SETUP_INTERRUPT_EVENT'>SETUP_INTERRUPT_EVENT</a></li>
</ul>
</li>
<li>
<a href='#Typedefs'>Typedefs</a>
<ul class='nav nav-stacked'>
<li><a href='#typedef_vmi_mode_t'>vmi_mode_t</a></li>
<li><a href='#typedef_status_t'>status_t</a></li>
<li><a href='#typedef_os_t'>os_t</a></li>
<li><a href='#typedef_win_ver_t'>win_ver_t</a></li>
<li><a href='#typedef_page_mode_t'>page_mode_t</a></li>
<li><a href='#typedef_page_size_t'>page_size_t</a></li>
<li><a href='#typedef_reg_t'>reg_t</a></li>
<li><a href='#typedef_registers_t'>registers_t</a></li>
<li><a href='#typedef_addr_t'>addr_t</a></li>
<li><a href='#typedef_vmi_pid_t'>vmi_pid_t</a></li>
<li><a href='#typedef_page_info_t'>page_info_t</a></li>
<li><a href='#typedef_translation_mechanism_t'>translation_mechanism_t</a></li>
<li><a href='#typedef_unicode_string_t'>unicode_string_t</a></li>
<li><a href='#typedef_vmi_config_t'>vmi_config_t</a></li>
<li><a href='#typedef_vmi_instance_t'>vmi_instance_t</a></li>
<li><a href='#typedef_vmi_event_t'>vmi_event_t</a></li>
<li><a href='#typedef_event_callback_t'>event_callback_t</a></li>
</ul>
</li>
<li>
<a href='#Enums'>Enums</a>
<ul class='nav nav-stacked'>
<li><a href='#enum_status'>status</a></li>
<li><a href='#enum_os'>os</a></li>
<li><a href='#enum_win_ver'>win_ver</a></li>
<li><a href='#enum_page_mode'>page_mode</a></li>
<li><a href='#enum_page_size'>page_size</a></li>
<li><a href='#enum_registers'>registers</a></li>
<li><a href='#enum_translation_mechanism'>translation_mechanism</a></li>
<li><a href='#enum_vmi_event_type_t'>vmi_event_type_t</a></li>
<li><a href='#enum_vmi_reg_access_t'>vmi_reg_access_t</a></li>
<li><a href='#enum_vmi_mem_access_t'>vmi_mem_access_t</a></li>
<li><a href='#enum_vmi_memevent_granularity_t'>vmi_memevent_granularity_t</a></li>
<li><a href='#enum_interrupts_t'>interrupts_t</a></li>
</ul>
</li>
<li>
<a href='#Functions'>Functions</a>
<ul class='nav nav-stacked'>
<li><a href='#func_vmi_init'>vmi_init</a></li>
<li><a href='#func_vmi_init_custom'>vmi_init_custom</a></li>
<li><a href='#func_vmi_init_complete'>vmi_init_complete</a></li>
<li><a href='#func_vmi_init_complete_custom'>vmi_init_complete_custom</a></li>
<li><a href='#func_vmi_init_paging'>vmi_init_paging</a></li>
<li><a href='#func_vmi_destroy'>vmi_destroy</a></li>
<li><a href='#func_vmi_translate_kv2p'>vmi_translate_kv2p</a></li>
<li><a href='#func_vmi_translate_uv2p'>vmi_translate_uv2p</a></li>
<li><a href='#func_vmi_translate_ksym2v'>vmi_translate_ksym2v</a></li>
<li><a href='#func_vmi_translate_sym2v'>vmi_translate_sym2v</a></li>
<li><a href='#func_vmi_translate_v2sym'>vmi_translate_v2sym</a></li>
<li><a href='#func_vmi_pid_to_dtb'>vmi_pid_to_dtb</a></li>
<li><a href='#func_vmi_dtb_to_pid'>vmi_dtb_to_pid</a></li>
<li><a href='#func_vmi_pagetable_lookup'>vmi_pagetable_lookup</a></li>
<li><a href='#func_vmi_pagetable_lookup_extended'>vmi_pagetable_lookup_extended</a></li>
<li><a href='#func_vmi_read'>vmi_read</a></li>
<li><a href='#func_vmi_read_8'>vmi_read_8</a></li>
<li><a href='#func_vmi_read_16'>vmi_read_16</a></li>
<li><a href='#func_vmi_read_32'>vmi_read_32</a></li>
<li><a href='#func_vmi_read_64'>vmi_read_64</a></li>
<li><a href='#func_vmi_read_addr'>vmi_read_addr</a></li>
<li><a href='#func_vmi_read_str'>vmi_read_str</a></li>
<li><a href='#func_vmi_read_ksym'>vmi_read_ksym</a></li>
<li><a href='#func_vmi_read_va'>vmi_read_va</a></li>
<li><a href='#func_vmi_read_pa'>vmi_read_pa</a></li>
<li><a href='#func_vmi_read_8_ksym'>vmi_read_8_ksym</a></li>
<li><a href='#func_vmi_read_16_ksym'>vmi_read_16_ksym</a></li>
<li><a href='#func_vmi_read_32_ksym'>vmi_read_32_ksym</a></li>
<li><a href='#func_vmi_read_64_ksym'>vmi_read_64_ksym</a></li>
<li><a href='#func_vmi_read_addr_ksym'>vmi_read_addr_ksym</a></li>
<li><a href='#func_vmi_read_str_ksym'>vmi_read_str_ksym</a></li>
<li><a href='#func_vmi_read_8_va'>vmi_read_8_va</a></li>
<li><a href='#func_vmi_read_16_va'>vmi_read_16_va</a></li>
<li><a href='#func_vmi_read_32_va'>vmi_read_32_va</a></li>
<li><a href='#func_vmi_read_64_va'>vmi_read_64_va</a></li>
<li><a href='#func_vmi_read_addr_va'>vmi_read_addr_va</a></li>
<li><a href='#func_vmi_read_str_va'>vmi_read_str_va</a></li>
<li><a href='#func_vmi_read_unicode_str_va'>vmi_read_unicode_str_va</a></li>
<li><a href='#func_vmi_convert_str_encoding'>vmi_convert_str_encoding</a></li>
<li><a href='#func_vmi_free_unicode_str'>vmi_free_unicode_str</a></li>
<li><a href='#func_vmi_read_8_pa'>vmi_read_8_pa</a></li>
<li><a href='#func_vmi_read_16_pa'>vmi_read_16_pa</a></li>
<li><a href='#func_vmi_read_32_pa'>vmi_read_32_pa</a></li>
<li><a href='#func_vmi_read_64_pa'>vmi_read_64_pa</a></li>
<li><a href='#func_vmi_read_addr_pa'>vmi_read_addr_pa</a></li>
<li><a href='#func_vmi_read_str_pa'>vmi_read_str_pa</a></li>
<li><a href='#func_vmi_write'>vmi_write</a></li>
<li><a href='#func_vmi_write_ksym'>vmi_write_ksym</a></li>
<li><a href='#func_vmi_write_va'>vmi_write_va</a></li>
<li><a href='#func_vmi_write_pa'>vmi_write_pa</a></li>
<li><a href='#func_vmi_write_8'>vmi_write_8</a></li>
<li><a href='#func_vmi_write_16'>vmi_write_16</a></li>
<li><a href='#func_vmi_write_32'>vmi_write_32</a></li>
<li><a href='#func_vmi_write_64'>vmi_write_64</a></li>
<li><a href='#func_vmi_write_addr'>vmi_write_addr</a></li>
<li><a href='#func_vmi_write_8_ksym'>vmi_write_8_ksym</a></li>
<li><a href='#func_vmi_write_16_ksym'>vmi_write_16_ksym</a></li>
<li><a href='#func_vmi_write_32_ksym'>vmi_write_32_ksym</a></li>
<li><a href='#func_vmi_write_64_ksym'>vmi_write_64_ksym</a></li>
<li><a href='#func_vmi_write_addr_ksym'>vmi_write_addr_ksym</a></li>
<li><a href='#func_vmi_write_8_va'>vmi_write_8_va</a></li>
<li><a href='#func_vmi_write_16_va'>vmi_write_16_va</a></li>
<li><a href='#func_vmi_write_32_va'>vmi_write_32_va</a></li>
<li><a href='#func_vmi_write_64_va'>vmi_write_64_va</a></li>
<li><a href='#func_vmi_write_addr_va'>vmi_write_addr_va</a></li>
<li><a href='#func_vmi_write_8_pa'>vmi_write_8_pa</a></li>
<li><a href='#func_vmi_write_16_pa'>vmi_write_16_pa</a></li>
<li><a href='#func_vmi_write_32_pa'>vmi_write_32_pa</a></li>
<li><a href='#func_vmi_write_64_pa'>vmi_write_64_pa</a></li>
<li><a href='#func_vmi_write_addr_pa'>vmi_write_addr_pa</a></li>
<li><a href='#func_vmi_print_hex'>vmi_print_hex</a></li>
<li><a href='#func_vmi_print_hex_ksym'>vmi_print_hex_ksym</a></li>
<li><a href='#func_vmi_print_hex_va'>vmi_print_hex_va</a></li>
<li><a href='#func_vmi_print_hex_pa'>vmi_print_hex_pa</a></li>
<li><a href='#func_vmi_get_name'>vmi_get_name</a></li>
<li><a href='#func_vmi_get_vmid'>vmi_get_vmid</a></li>
<li><a href='#func_vmi_get_access_mode'>vmi_get_access_mode</a></li>
<li><a href='#func_vmi_get_page_mode'>vmi_get_page_mode</a></li>
<li><a href='#func_vmi_get_address_width'>vmi_get_address_width</a></li>
<li><a href='#func_vmi_get_ostype'>vmi_get_ostype</a></li>
<li><a href='#func_vmi_get_winver'>vmi_get_winver</a></li>
<li><a href='#func_vmi_get_winver_str'>vmi_get_winver_str</a></li>
<li><a href='#func_vmi_get_winver_manual'>vmi_get_winver_manual</a></li>
<li><a href='#func_vmi_get_offset'>vmi_get_offset</a></li>
<li><a href='#func_vmi_get_memsize'>vmi_get_memsize</a></li>
<li><a href='#func_vmi_get_num_vcpus'>vmi_get_num_vcpus</a></li>
<li><a href='#func_vmi_get_vcpureg'>vmi_get_vcpureg</a></li>
<li><a href='#func_vmi_set_vcpureg'>vmi_set_vcpureg</a></li>
<li><a href='#func_vmi_pause_vm'>vmi_pause_vm</a></li>
<li><a href='#func_vmi_resume_vm'>vmi_resume_vm</a></li>
<li><a href='#func_vmi_v2pcache_flush'>vmi_v2pcache_flush</a></li>
<li><a href='#func_vmi_v2pcache_add'>vmi_v2pcache_add</a></li>
<li><a href='#func_vmi_symcache_flush'>vmi_symcache_flush</a></li>
<li><a href='#func_vmi_symcache_add'>vmi_symcache_add</a></li>
<li><a href='#func_vmi_rvacache_flush'>vmi_rvacache_flush</a></li>
<li><a href='#func_vmi_rvacache_add'>vmi_rvacache_add</a></li>
<li><a href='#func_vmi_pidcache_flush'>vmi_pidcache_flush</a></li>
<li><a href='#func_vmi_pidcache_add'>vmi_pidcache_add</a></li>
<li><a href='#func_vmi_register_event'>vmi_register_event</a></li>
<li><a href='#func_vmi_clear_event'>vmi_clear_event</a></li>
<li><a href='#func_vmi_get_reg_event'>vmi_get_reg_event</a></li>
<li><a href='#func_vmi_get_mem_event'>vmi_get_mem_event</a></li>
<li><a href='#func_vmi_step_event'>vmi_step_event</a></li>
<li><a href='#func_vmi_events_listen'>vmi_events_listen</a></li>
<li><a href='#func_vmi_event_listener_required'>vmi_event_listener_required</a></li>
<li><a href='#func_vmi_are_events_pending'>vmi_are_events_pending</a></li>
<li><a href='#func_vmi_get_singlestep_event'>vmi_get_singlestep_event</a></li>
<li><a href='#func_vmi_stop_single_step_vcpu'>vmi_stop_single_step_vcpu</a></li>
<li><a href='#func_vmi_shutdown_single_step'>vmi_shutdown_single_step</a></li>
</ul>
</li>

    </ul>
    

      </div>
    </nav>
    
</div>
